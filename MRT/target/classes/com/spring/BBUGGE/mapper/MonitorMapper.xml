<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"

        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">


<mapper namespace="com.spring.BBUGGE.mapper.MonitorMapper">
    <!--검색-->
	<select id="selectNum" resultType="java.util.HashMap">
		SELECT 1 FROM DUAL;
	</select>
	
	<!-- Database Info -->
	<select id="selectDatabaseInfo" resultType="java.util.HashMap">
		SELECT 
			DB_NAME
			, LOGFILE_SIZE
			, MEM_MAX_DB_SIZE
			, MEM_ALLOC_PAGE_COUNT
			, MEM_FREE_PAGE_COUNT
			, MAX_ACCESS_FILE_SIZ
		FROM V$DATABASE;
	</select>
	<select id="selectDatabaseVersion" resultType="java.util.HashMap">
		SELECT
			PRODUCT_VERSION
			, SM_VERSION
			, META_VERSION
			, PROTOCOL_VERSION
			, REPL_PROTOCOL_VERSION
		FROM V$VERSION;
	</select>
	
	<!-- Replication -->
	<select id="selectReplCheck" resultType="java.util.HashMap">
		SELECT DECODE(COUNT('x'),0,0,1) AS REPL_CHK FROM SYSTEM_.SYS_REPLICATIONS_;
	</select>
	<select id="selectReplGapList" resultType="java.util.HashMap">
		SELECT REP_NAME
			, REP_GAP
		FROM V$REPGAP;
	</select>
	<select id="selectReplGapForMonitorAjaxList" resultType="java.util.HashMap">
		SELECT REP_NAME AS KEY
			, REP_GAP AS VALUE
		FROM V$REPGAP;
	</select>
	<select id="selectReplItemList" resultType="java.util.HashMap">
		SELECT REPLICATION_NAME REP_NAME
			, LOCAL_USER_NAME||'.'||LOCAL_TABLE_NAME LOCAL_TBL
			, REMOTE_USER_NAME||'.'||REMOTE_TABLE_NAME REMOTE_TBL
		FROM SYSTEM_.SYS_REPL_ITEMS_
		ORDER BY 1, 2;
	</select>
	<select id="selectLogfileForReplList" resultType="java.util.HashMap">
		SELECT CASE2((READ_SN > BUFFER_MIN_SN),
			'REP BUFFER '||ROUND((BUFFER_MAX_SN-READ_SN)/(BUFFER_MAX_SN-BUFFER_MIN_SN)*100, 2)||' % LEFT ',
			(SELECT TO_CHAR(CUR_WRITE_LF_NO - READ_FILE_NO) FROM V$LFG, V$REPGAP)
			) LOGFILE_FOR_REP
		FROM V$REPLOGBUFFER;
	</select>
	<select id="selectReplWholeStatusList" resultType="java.util.HashMap">
		SELECT A.REPLICATION_NAME REP_NAME
			, D.HOST_IP REMOTE_IP
			, NVL(TO_CHAR(E.REP_GAP), '-') AS REP_GAP
			, A.XSN RESTART_XSN
			, DECODE(B.PEER_PORT, NULL, 'OFF', 'ON') AS SENDER
			, DECODE(C.PEER_PORT, NULL, 'OFF', 'ON') AS RECEIVER
		FROM SYSTEM_.SYS_REPL_HOSTS_ D ,
			SYSTEM_.SYS_REPLICATIONS_ A
			LEFT OUTER JOIN V$REPSENDER B ON A.REPLICATION_NAME = B.REP_NAME
			LEFT OUTER JOIN V$REPRECEIVER C ON A.REPLICATION_NAME = C.REP_NAME
			LEFT OUTER JOIN (SELECT REP_NAME, MAX(REP_GAP) REP_GAP
							FROM V$REPGAP
							GROUP BY REP_NAME) E ON A.REPLICATION_NAME = E.REP_NAME
		WHERE A.REPLICATION_NAME = D.REPLICATION_NAME
		ORDER BY REP_NAME;
	</select>
	
	<!-- Memory  -->
	<select id="selectMemoryUsageWhenUseMemoryDB" resultType="java.util.HashMap">
		SELECT
			A.UNIT 
			, A.MEM_MAX_DB_SIZE/A.DIVIDER AS 'MAX'
			, ROUND(A.MEM_ALLOC_PAGE_COUNT*32/A.DIVIDER*1024, 2) 'TOTAL'
			, TRUNC((A.MEM_ALLOC_PAGE_COUNT-A.MEM_FREE_PAGE_COUNT)*32/A.DIVIDER*1024, 2) 'ALLOC'
			, (SELECT ROUND(SUM((FIXED_USED_MEM + VAR_USED_MEM))/(A.DIVIDER), 3)
		         FROM V$MEMTBL_INFO) 'USED'
			, TRUNC(((A.MEM_ALLOC_PAGE_COUNT-A.MEM_FREE_PAGE_COUNT)*32*1024)/MEM_MAX_DB_SIZE, 4)*100 'USAGE'
		FROM (SELECT 
				(CASE WHEN MEM_MAX_DB_SIZE > 1024000 THEN 'M' 
					WHEN MEM_MAX_DB_SIZE > 1048576000 THEN 'G' 
					WHEN MEM_MAX_DB_SIZE > 1073741824000 THEN 'T' 
					WHEN MEM_MAX_DB_SIZE > 1099511627776000 THEN 'P' 
					WHEN MEM_MAX_DB_SIZE > 1125899906842624000 THEN 'E' 
			END) AS UNIT
			, (CASE WHEN MEM_MAX_DB_SIZE > 1024000 THEN 1048576 
					WHEN MEM_MAX_DB_SIZE > 1048576000 THEN 1073741824 
					WHEN MEM_MAX_DB_SIZE > 1073741824000 THEN 1099511627776 
					WHEN MEM_MAX_DB_SIZE > 1099511627776000 THEN 1125899906842624
					WHEN MEM_MAX_DB_SIZE > 1125899906842624000 THEN 1152921504606847000 
				END) AS DIVIDER
				, MEM_MAX_DB_SIZE
				, MEM_ALLOC_PAGE_COUNT
				, MEM_FREE_PAGE_COUNT
			FROM V$DATABASE) A;
	</select>
	<!-- Tablespace Usage -->
	<select id="selectMemoryTablespaceUsageList" resultType="java.util.HashMap">
		SELECT T.TBS_ID
			, T.TBS_TYPE
			, T.TBS_NAME
			, T.UNIT
			, T.DIVIDER
			, TO_CHAR( T.MAX / T.DIVIDER , '999,999,999') AS MAX
			, TO_CHAR( T.TOTAL / T.DIVIDER , '999,999,999') AS TOTAL
			, TO_CHAR( T.ALLOC / T.DIVIDER , '999,999,999') AS ALLOC
			, TO_CHAR( T.USED / T.DIVIDER , '999,999,999') AS USED
			, T.USAGE
			, T.STATE
			, T.AUTOEXTEND
		FROM (SELECT A.TBS_ID
				, A.TBS_TYPE
				, A.TBS_NAME
				, (CASE WHEN A.MAX > 1024000 THEN 'M' 
					WHEN A.MAX > 1048576000 THEN 'G' 
					WHEN A.MAX > 1073741824000 THEN 'T' 
					WHEN A.MAX > 1099511627776000 THEN 'P' 
					WHEN A.MAX > 1125899906842624000 THEN 'E' 
				END) AS UNIT
				, (CASE WHEN A.MAX > 1024000 THEN 1048576 
					WHEN A.MAX > 1048576000 THEN 1073741824 
					WHEN A.MAX > 1073741824000 THEN 1099511627776 
					WHEN A.MAX > 1099511627776000 THEN 1125899906842624
					WHEN A.MAX > 1125899906842624000 THEN 1152921504606847000 
				END) AS DIVIDER
				, A.MAX
				, A.TOTAL
				, A.ALLOC
				, A.USED
				, A.USAGE
				, A.STATE
				, A.AUTOEXTEND
			FROM (SELECT ID AS TBS_ID 
					, DECODE(TYPE, 0, 'MEMORY_DICTIONARY', 1, 'MEMORY_SYS_DATA', 2, 'MEMORY_USER_DATA', 8, 'VOLATILE_USER_DATA') AS TBS_TYPE 
					, NAME AS TBS_NAME 
					, DECODE(M.MAXSIZE, 140737488322560, D.MEM_MAX_DB_SIZE , 0 , T.TOTAL_PAGE_COUNT * T.PAGE_SIZE, M.MAXSIZE) AS MAX
					, M.ALLOC_PAGE_COUNT * T.PAGE_SIZE  AS TOTAL
					, NVL(M.ALLOC_PAGE_COUNT - M.FREE_PAGE_COUNT,T.TOTAL_PAGE_COUNT) * PAGE_SIZE AS ALLOC
					, NVL(MT.USED, 0) AS USED
					, TO_CHAR(DECODE(MAXSIZE, 140737488322560, (M.ALLOC_PAGE_COUNT-M.FREE_PAGE_COUNT)*T.PAGE_SIZE/ D.MEM_MAX_DB_SIZE ,0, (M.ALLOC_PAGE_COUNT-M.FREE_PAGE_COUNT) / T.TOTAL_PAGE_COUNT , (M.ALLOC_PAGE_COUNT-M.FREE_PAGE_COUNT) * T.PAGE_SIZE/ M.MAXSIZE) * 100 , '99.99') AS USAGE 
					, DECODE(T.STATE,1,'OFFLINE',2,'ONLINE',5,'OFFLINE BACKUP',6,'ONLINE BACKUP',128,'DROPPED', 'DISCARDED') AS STATE 
					, DECODE(M.AUTOEXTEND_MODE,1,'ON','OFF') AS AUTOEXTEND
				FROM V$DATABASE D 
					, V$TABLESPACES T 
					, (SELECT SPACE_ID 
							, SPACE_NAME 
							, ALLOC_PAGE_COUNT 
							, FREE_PAGE_COUNT 
							, DECODE(MAX_SIZE, 0, (SELECT VALUE1 FROM V$PROPERTY WHERE NAME = 'VOLATILE_MAX_DB_SIZE'), MAX_SIZE) AS MAXSIZE 
							, AUTOEXTEND_MODE 
						FROM V$VOL_TABLESPACES 
						UNION 
						SELECT SPACE_ID 
							, SPACE_NAME 
							, ALLOC_PAGE_COUNT 
							, FREE_PAGE_COUNT 
							, MAXSIZE 
							, AUTOEXTEND_MODE 
						FROM V$MEM_TABLESPACES ) M 
						LEFT OUTER JOIN (SELECT TABLESPACE_ID, ROUND(SUM((FIXED_USED_MEM + VAR_USED_MEM))/(1024*1024),3) USED FROM V$MEMTBL_INFO 
						GROUP BY TABLESPACE_ID ) MT ON M.SPACE_ID = MT.TABLESPACE_ID 
				WHERE T.ID = M.SPACE_ID) A 
			) T;
	</select>
	<select id="selectDiskTablespaceUsageList" resultType="java.util.HashMap">
		SELECT T.TBS_ID
			, T.TBS_TYPE
			, T.TBS_NAME
			, T.UNIT
			, T.DIVIDER
			, TO_CHAR( T.MAX / T.DIVIDER , '999,999,999') AS MAX
			, TO_CHAR( T.TOTAL / T.DIVIDER , '999,999,999') AS TOTAL
			, TO_CHAR( T.ALLOC / T.DIVIDER , '999,999,999') AS ALLOC
			, TO_CHAR( T.USED / T.DIVIDER , '999,999,999') AS USED
			, T.USAGE
			, T.STATE
			, T.AUTOEXTEND
		FROM (SELECT A.TBS_ID
					, A.TBS_TYPE
					, A.TBS_NAME
					,(CASE WHEN A.MAX > 1024000 THEN 'M' 
						WHEN A.MAX > 1048576000 THEN 'G' 
						WHEN A.MAX > 1073741824000 THEN 'T' 
						WHEN A.MAX > 1099511627776000 THEN 'P' 
						WHEN A.MAX > 1125899906842624000 THEN 'E' 
					END) AS UNIT
					, (CASE WHEN A.MAX > 1024000 THEN 1048576 
						WHEN A.MAX > 1048576000 THEN 1073741824 
						WHEN A.MAX > 1073741824000 THEN 1099511627776 
						WHEN A.MAX > 1099511627776000 THEN 1125899906842624
						WHEN A.MAX > 1125899906842624000 THEN 1152921504606847000 
					END) AS DIVIDER   
					, A.MAX
					, A.TOTAL
					, A.ALLOC
					, A.USED
					, A.USAGE
					, A.STATE
					, A.AUTOEXTEND
				FROM (SELECT T.ID AS TBS_ID
					, DECODE(TYPE, 3, 'SYSTEM_DISK_DATA', 4, 'DISK_USER_DATA', 5, 'SYSTEM_DISK_TEMP', 6, 'USER_DISK_TEMP', 7, 'SYSTEM_DISK_UNDO') AS TBS_TYPE  
					, NAME AS TBS_NAME
					, D.MAX * PAGE_SIZE  AS MAX
					, TOTAL_PAGE_COUNT * PAGE_SIZE AS TOTAL
					, DECODE(TYPE, 7, U.TOTAL_EXT_CNT * PROP.EXTENT_SIZE 
									, ALLOCATED_PAGE_COUNT * PAGE_SIZE) AS ALLOC
					, DECODE(TYPE, 3, NVL(DS.USED, 0),  
									4, NVL(DS.USED, 0),  
									7, ( U.TX_EXT_CNT + U.USED_EXT_CNT + U.UNSTEALABLE_EXT_CNT) * PROP.EXTENT_SIZE) AS USED
					, TO_CHAR(DECODE(TYPE, 7, ((U.TX_EXT_CNT + U.USED_EXT_CNT + U.UNSTEALABLE_EXT_CNT) * PROP.EXTENT_SIZE) / (D.MAX * PAGE_SIZE),
									3, NVL(DS.USED, 0) / (D.MAX * PAGE_SIZE),  
									4, NVL(DS.USED, 0) / (D.MAX * PAGE_SIZE)  
									, ALLOCATED_PAGE_COUNT / D.MAX) * 100, '99.99') AS USAGE
					, DECODE(STATE, 1, 'OFFLINE', 2, 'ONLINE', 5, 'OFFLINE BACKUP', 6, 'ONLINE BACKUP', 128, 'DROPPED', 'DISCARDED') AS STATE 
					, D.AUTOEXTEND  
				FROM V$TABLESPACES T LEFT OUTER JOIN(SELECT SPACE_ID , SUM(TOTAL_USED_SIZE) USED  
														FROM X$SEGMENT  
														GROUP BY SPACE_ID) DS ON DS.SPACE_ID = T.ID  
					, (SELECT SPACEID  
							, SUM(DECODE(MAXSIZE, 0, CURRSIZE, MAXSIZE)) AS MAX  
							, DECODE(MAX(AUTOEXTEND), 1, 'ON', 'OFF') 'AUTOEXTEND'  
						FROM V$DATAFILES  
						GROUP BY SPACEID ) D  
					, V$DISK_UNDO_USAGE U  
					, (SELECT VALUE1 EXTENT_SIZE  
						FROM V$PROPERTY  
						WHERE NAME = 'SYS_UNDO_TBS_EXTENT_SIZE') PROP  
				WHERE T.ID = D.SPACEID) A
			) T; 
	</select>
	
	<!-- GC -->
	<select id="selectGCGapList" resultType="java.util.HashMap">
		SELECT GC_NAME
			, SCNOFTAIL
			, MINMEMSCNINTXS
			, ADD_OID_CNT-GC_OID_CNT AS GC_GAP
		FROM V$MEMGC;
	</select>
	<select id="selectGCGapForMonitorAjaxList" resultType="java.util.HashMap">
		SELECT GC_NAME AS KEY
			, ADD_OID_CNT-GC_OID_CNT AS VALUE
		FROM V$MEMGC;
	</select>
	<select id="selectQueryUsingGCByWaitingTransactionList" resultType="java.util.HashMap">
		SELECT ST.SESSION_ID
			, ST.ID AS STMT_ID
			, ST.TX_ID
			, DB_USERNAME
			, SS.MODULE
			, SS.CLIENT_APP_INFO AS APP_INFO
			, SS.COMM_NAME
			, LTRIM(ST.QUERY) AS QUERY
			, ROUND((ST.PARSE_TIME+ST.VALIDATE_TIME+ST.OPTIMIZE_TIME)/1000000, 1) AS PREPARE_TIME
			, ROUND(ST.FETCH_TIME/1000000, 1) AS FETCH_TIME
			, ROUND(ST.EXECUTE_TIME/1000000, 1) AS EXECUTE_TIME
			, ROUND(ST.TOTAL_TIME/1000000, 1) AS TOTAL_TIME
			, DECODE(ST.LAST_QUERY_START_TIME, 0, '-', TO_CHAR(TO_DATE('1970010109', 'YYYYMMDDHH') + ST.LAST_QUERY_START_TIME / (24*60*60), 'YYYY/MM/DD HH:MI:SS')) AS LAST_START_TIME
		FROM V$STATEMENT ST, V$SESSION SS
		WHERE ST.SESSION_ID = SS.ID
		AND ST.EXECUTE_FLAG = 1
		AND ST.EXECUTE_TIME/1000000 > <choose><when test="query_time != null">#{query_time}</when><otherwise>600</otherwise></choose>   -- 쿼리 수행 시간 조건을 변경하면 이 조건의 값을 변경하면 된다. 값은 초 단위이다. 
		ORDER BY ST.EXECUTE_TIME DESC;
	</select>

	<!-- Lock -->
	<select id="selectLockCntForMonitorAjax" resultType="java.util.HashMap">
		SELECT 'LOCK_CNT' AS KEY, COUNT('x') AS VALUE FROM V$LOCK L, V$TRANSACTION T WHERE T.ID = L.TRANS_ID AND STATUS IN (0,1,4,5);
	</select>
	<select id="selectLockDetailList" resultType="java.util.HashMap">
		SELECT 
		LEVEL
		, T.TX_ID
		, T.BLOCKED_TX_ID
		, T.STATUS
		, USER_NAME
		, SESSION_ID
		, CLIENT_IP
		, AUTOCOMMIT
		, LOCK_DESC
		, FIRST_UPDATE_TIME
		, TABLE_NAME
		, CURRENT_QUERY
		, DDL
		, LOG_FILE
		FROM (
		SELECT TX.ID TX_ID
					, WAIT_FOR_TRANS_ID BLOCKED_TX_ID
					, DECODE(TX.STATUS,
								0, 'BEGIN',
								1, 'PRECOMMIT',
								2, 'COMMIT_IN_MEMORY',
								3, 'COMMIT',
								4, 'ABORT', --(ROLLBACK) v.6.1.1 higher
								5, 'BLOCKED',
								6, 'END') STATUS
					, DECODE(TX.LOG_TYPE, 0, U1.USER_NAME, 'REPLICATION') USER_NAME
					, DECODE(TX.LOG_TYPE, 0, TX.SESSION_ID, RT.REP_NAME) SESSION_ID
					, DECODE(TX.LOG_TYPE, 0, ST.COMM_NAME, RR.PEER_IP) CLIENT_IP
					, DECODE(ST.AUTOCOMMIT_FLAG, 1, 'ON', 'OFF') AUTOCOMMIT
					, L.LOCK_DESC
					, DECODE(TX.FIRST_UPDATE_TIME, 
								0, '0',
								TO_CHAR(TO_DATE('1970010109', 'YYYYMMDDHH') + TX.FIRST_UPDATE_TIME / (60*60*24), 'MM/DD HH:MI:SS')) FIRST_UPDATE_TIME
					, U2.USER_NAME||'.'||T.TABLE_NAME TABLE_NAME
					, DECODE(TX.LOG_TYPE, 0, SUBSTR(ST.QUERY, 1, 30), 'REMOTE TX_ID '||REMOTE_TID) CURRENT_QUERY
					, DECODE(TX.DDL_FLAG, 0, 'NON-DDL', 'DDL') DDL
					, DECODE(TX.FIRST_UNDO_NEXT_LSN_FILENO, -1, '-', TX.FIRST_UNDO_NEXT_LSN_FILENO) LOG_FILE
				FROM V$TRANSACTION TX,
					V$LOCK L
				LEFT OUTER JOIN (SELECT ST.*, SS.AUTOCOMMIT_FLAG, SS.DB_USERID, SS.COMM_NAME
								FROM V$STATEMENT ST, V$SESSION SS
								WHERE SS.ID = ST.SESSION_ID
								AND SS.CURRENT_STMT_ID = ST.ID) ST ON L.TRANS_ID = ST.TX_ID
				LEFT OUTER JOIN V$REPRECEIVER_TRANSTBL RT ON L.TRANS_ID = RT.LOCAL_TID
				LEFT OUTER JOIN V$REPRECEIVER RR ON RT.REP_NAME = RR.REP_NAME
				LEFT OUTER JOIN V$LOCK_WAIT LW ON L.TRANS_ID = LW.TRANS_ID
				LEFT OUTER JOIN SYSTEM_.SYS_USERS_ U1 ON ST.DB_USERID = U1.USER_ID,
					SYSTEM_.SYS_TABLES_ T
				LEFT OUTER JOIN SYSTEM_.SYS_USERS_ U2 ON T.USER_ID = U2.USER_ID
				WHERE TX.ID = L.TRANS_ID
				AND T.TABLE_OID = L.TABLE_OID
				AND TX.STATUS != 6) T
		START WITH BLOCKED_TX_ID IS NULL 
		CONNECT BY PRIOR TX_ID = BLOCKED_TX_ID;
	</select>
	
	<!-- Session -->
	<select id="selectActiveSessionCntForMonitorAjax" resultType="java.util.HashMap">
		SELECT 'ACTV_SESS_CNT' AS KEY, COUNT('x') AS VALUE FROM V$SESSION WHERE ACTIVE_FLAG=0;
	</select>
	<select id="selectPropertyMaxClient" resultType="java.util.HashMap">
		SELECT VALUE1 AS MAX_CLIENT FROM V$PROPERTY WHERE NAME = 'MAX_CLIENT';
	</select>
	<!-- # Active Session Detail -->
	
	<!-- Statement -->
	<select id="selectActiveStatementCntForMonitorAjax" resultType="java.util.HashMap">
		SELECT 'ACTV_STMT_CNT' AS KEY, COUNT('x') AS VALUE
		FROM V$STATEMENT
		WHERE EXECUTE_FLAG = 1 ;
	</select>
	<select id="selectPropertyMaxStatementPerSession" resultType="java.util.HashMap">
		SELECT VALUE1 AS MAX_STMT_PER_SESS FROM V$PROPERTY WHERE NAME = 'MAX_STATEMENTS_PER_SESSION';
	</select>
	
	<!-- Slow Query -->
	<select id="selectSlowQueryList" parameterType="java.util.HashMap" resultType="java.util.HashMap">
		SELECT SESSION_ID
			, ID STMT_ID
			, TX_ID
			, ROUND((PARSE_TIME+VALIDATE_TIME+OPTIMIZE_TIME)/1000000, 1) PREPARE_TIME
			, ROUND(FETCH_TIME/1000000, 1) FETCH_TIME
			, ROUND(EXECUTE_TIME/1000000, 1) EXECUTE_TIME
			, ROUND(TOTAL_TIME/1000000, 1) TOTAL_TIME
			, DECODE(LAST_QUERY_START_TIME, 0, '-', TO_CHAR(TO_DATE('1970010109', 'YYYYMMDDHH') + LAST_QUERY_START_TIME / (24*60*60), 'MM/DD HH:MI:SS')) LAST_START_TIME
			, LTRIM(QUERY) QUERY
		FROM V$STATEMENT
		WHERE EXECUTE_FLAG = 1
		AND EXECUTE_TIME/1000000 > <choose><when test="query_time != null">#{query_time}</when><otherwise>600</otherwise></choose>   -- 쿼리 수행 시간 조건을 변경하면 이 조건의 값을 변경하면 된다. 값은 초 단위이다. 
		ORDER BY EXECUTE_TIME DESC;
	</select>
		
	<select id="selectSessionStatementList" resultType="java.util.HashMap">
		SELECT
			SS.ID AS SESSION_ID
			, SS.DB_USERNAME
			, SS.MODULE
			, SS.CLIENT_APP_INFO
			, SS.COMM_NAME
			, SS.ACTION
			, DECODE(ST.EVENT,'no wait event',NULL,ST.EVENT) AS EVENT
			, ST.TX_ID
			, DECODE(SS.ACTIVE_FLAG,1,'ACTIVE','INACTIVE') AS ACTIVE
			, SS.TASK_STATE AS STATE
			, ST.QUERY
			, ST.COST
			, DECODE(ST.QUERY_START_TIME,0,NULL,TO_CHAR(TO_DATE('1970010109', 'YYYYMMDDHH') + ST.QUERY_START_TIME / (60*60*24), 'YYYY/MM/DD HH24:MI:SS')) AS QUERY_START_TIME
			, ST.USED_MEMORY
			, ST.READ_PAGE
			, ST.WRITE_PAGE
			, ST.GET_PAGE
			, ST.CREATE_PAGE
			, ST.UNDO_READ_PAGE
			, ST.UNDO_WRITE_PAGE
			, ST.UNDO_GET_PAGE
			, ST.UNDO_CREATE_PAGE
			, DECODE(SS.IDLE_START_TIME,0,NULL,TO_CHAR(TO_DATE('1970010109', 'YYYYMMDDHH') + SS.IDLE_START_TIME / (60*60*24), 'YYYY/MM/DD HH24:MI:SS')) AS IDLE_START_TIME
			, DECODE(ST.LAST_QUERY_START_TIME,0,NULL,TO_CHAR(TO_DATE('1970010109', 'YYYYMMDDHH') + ST.LAST_QUERY_START_TIME / (60*60*24), 'YYYY/MM/DD HH24:MI:SS')) AS LAST_QUERY_START_TIME
			, DECODE(SS.LOGIN_TIME,0,NULL,TO_CHAR(TO_DATE('1970010109', 'YYYYMMDDHH') + SS.LOGIN_TIME / (60*60*24), 'YYYY/MM/DD HH24:MI:SS')) AS LOGIN_TIME
		FROM V$STATEMENT ST, V$SESSION SS
		WHERE SS.ID = ST.SESSION_ID
		AND SS.CURRENT_STMT_ID = ST.ID
		AND SS.DB_USERNAME != 'ALTIMON'
		AND SS.ACTIVE_FLAG = 1;
	</select>
	<!-- # Active Statement Detail -->
</mapper>

